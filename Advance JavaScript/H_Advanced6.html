<script>
/*
Currying is used in JavaScript to break down complex function calls into smaller, more manageable steps. 
It transforms a function with multiple arguments into a series of functions, each taking a single argument.

It converts a function with multiple parameters into a sequence of functions.
Each function takes a single argument and returns another function until all arguments are received.
Helps in functional programming by enabling function reusability and composition.
*/
// Normal Function
// function add(a, b) {
//     return a + b;
// }
// console.log(add(2, 3)); 

// Function Currying
function add(a) {
    return function(b) {
        return a + b;
    }
}

const addTwo = add(5);  // First function call with 5
console.log("Currying: "+addTwo(4));  


/*
How Currying Works in JavaScript?
Currying function in the JavaScript can be done manually, but it can also be done using the closure. 
Below it is shown that how currying function works.

Creating the First Function: The first function takes the first argument and gives back a new function to take the next one.
Returning a New Function: The returned function takes the next argument and keeps going until all the arguments are given.
Returning the Result: Once all the arguments are provided, the final result is calculated and returned.
*/
/*
Advantages of Currying Function::

It helps us to create a higher-order function
It reduces the chances of error in our function by dividing it into multiple smaller functions that
 can handle one responsibility.
It is very useful in building modular and reusable code
It helps us to avoid passing the same variable multiple times
It makes the code more readable

When to Use Currying in JavaScript?

In JavaScript, currying function is used in the following cases:

Partial Application: In the partial application we set some arguments in advance in the
 function and call it later with the remaining arguments.
Higher-Order Functions: When one function takes the other functions as arguments (eg: map, filter, reduce)
 in that case we can use the currying function to manage the arguments more effectively.
Functional Programming: Where functions are treated as important and focus is on not 
changing data and combining functions in those cases currying works perfectly.

*/

//Currying with Arrow Functions

const addarrow = a => b => a + b;
console.log("Currying with Arrow Functions:: "+addarrow(5)(4));  

//Arrow functions can be used to return new functions based on initial parameters, allowing for dynamic function creation.

const add111 = a => b => a + b;
const createAdder = a => b => add111(a)(b);

const addFive = createAdder(1);
console.log("Returning Functions from Functions: "+addFive(2));


</script>